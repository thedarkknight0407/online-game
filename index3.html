<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Online Co-Op with Password</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
      body {
        background: #111;
        color: white;
        text-align: center;
        font-family: sans-serif;
      }
      canvas {
        background: #222;
        display: block;
        margin: 10px auto;
      }
      input,
      button {
        font-size: 16px;
        margin: 5px;
      }
    </style>
  </head>
  <body>
    <h2>Stay Together ❤️</h2>

    <div id="menu">
      <input
        id="room"
        placeholder="Room code (leave empty to host new)"
        autocomplete="off"
      /><br />
      <input
        id="password"
        type="password"
        placeholder="Password (required)"
      /><br />
      <button onclick="host()">Host</button>
      <button onclick="join()">Join</button>
      <p
        id="info"
        style="
          color: white;
          background: rgba(255, 255, 255, 0.1);
          padding: 10px;
          border-radius: 8px;
          width: 320px;
          margin: 10px auto;
          font-weight: bold;
          min-height: 1.2em;
          user-select: none;
        "
      ></p>
    </div>

    <canvas id="c" width="600" height="400" style="display: none"></canvas>

    <script>
      const c = document.getElementById("c");
      const ctx = c.getContext("2d");

      let peer, conn;
      let me = { x: 200, y: 200 };
      let other = { x: 350, y: 200 };

      const info = document.getElementById("info");

      function randomId(length = 4) {
        const chars = "ABCDEFGHJKMNPQRSTUVWXYZ1023456789"; // avoid confusing letters
        let result = "";
        for (let i = 0; i < length; i++) {
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }

      // Create peer with custom short id
      function createPeer(id) {
        return new Peer(id, {
          config: {
            iceServers: [
              // Public Google STUN servers
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
              { urls: "stun:stun4.l.google.com:19302" },

              // Reliable free TURN server from Xirsys (works across NAT/firewalls)
              // {
              //   urls: "turn:global.turn.xirsys.com:3478?transport=udp",
              //   username: "YOUR_XIRSYS_USERNAME",
              //   credential: "YOUR_XIRSYS_CREDENTIAL",
              // },
              // {
              //   urls: "turn:global.turn.xirsys.com:3478?transport=tcp",
              //   username: "YOUR_XIRSYS_USERNAME",
              //   credential: "YOUR_XIRSYS_CREDENTIAL",
              // },
            ],
          },
        });
      }

      function host() {
        const password = document.getElementById("password").value.trim();
        if (!password) {
          showMessage("Password required to host", "error");

          return;
        }
        const roomId = randomId();
        peer = createPeer(roomId);
        peer.on("open", (id) => {
          info.style.color = "lightgreen";
          info.textContent = `Room code: ${id} | Password: (hidden)`;
          document.getElementById("room").value = id; // autofill join box with room code
        });
        peer.on("connection", (c) => {
          c.on("open", () => {
            // Wait for password from joiner
            c.on("data", (data) => {
              if (typeof data === "string" && data.startsWith("PWD:")) {
                const passAttempt = data.slice(4);
                if (passAttempt === password) {
                  conn = c;
                  c.send("PWD:ACCEPT");
                  start();
                } else {
                  c.send("PWD:REJECT");
                  c.close();
                  showMessage("Password required to host", "error");
                }
              }
            });
          });
        });
      }

      function join() {
        const roomId = document
          .getElementById("room")
          .value.trim()
          .toUpperCase();
        const password = document.getElementById("password").value.trim();
        if (!roomId || !password) {
          showMessage("Password required to host", "error");
          return;
        }
        peer = createPeer();
        peer.on("open", () => {
          conn = peer.connect(roomId);
          conn.on("open", () => {
            // Send password to host
            conn.send("PWD:" + password);
          });
          conn.on("data", (data) => {
            if (data === "PWD:ACCEPT") {
              info.style.color = "lightgreen";
              info.textContent = "Password accepted. Connected!";
              start();
            } else if (data === "PWD:REJECT") {
              info.style.color = "lightcoral";
              info.textContent = "Wrong password. Connection closed.";
              conn.close();
            } else {
              // game data
              try {
                const parsed = JSON.parse(data);
                if (typeof parsed === "object") other = parsed;
              } catch {}
            }
          });
        });
        peer.on("error", (err) => {
          info.style.color = "lightcoral";
          info.textContent = "Error: " + err;
        });
      }

      function start() {
        document.getElementById("menu").style.display = "none";
        c.style.display = "block";

        conn.on("data", (data) => {
          // Ignore password messages here
          if (typeof data === "string" && data.startsWith("PWD:")) return;
          try {
            const parsed = JSON.parse(data);
            if (typeof parsed === "object") other = parsed;
          } catch {}
        });

        loop();
      }

      document.onkeydown = (e) => {
        if (!conn || !conn.open) return;
        if (["w", "a", "s", "d"].includes(e.key.toLowerCase())) {
          if (e.key.toLowerCase() === "w") me.y -= 5;
          if (e.key.toLowerCase() === "s") me.y += 5;
          if (e.key.toLowerCase() === "a") me.x -= 5;
          if (e.key.toLowerCase() === "d") me.x += 5;

          // Clamp inside canvas
          me.x = Math.min(Math.max(me.x, 0), c.width - 20);
          me.y = Math.min(Math.max(me.y, 0), c.height - 20);

          conn.send(JSON.stringify(me));
        }
      };

      function loop() {
        ctx.clearRect(0, 0, c.width, c.height);
        ctx.fillStyle = "hotpink";
        ctx.fillRect(me.x, me.y, 20, 20);
        ctx.fillStyle = "cyan";
        ctx.fillRect(other.x, other.y, 20, 20);
        requestAnimationFrame(loop);
      }

      function showMessage(text, type = "info", duration = 5000) {
        const colors = {
          info: "white",
          success: "lightgreen",
          error: "lightcoral",
          warning: "orange",
        };
        info.style.color = colors[type] || colors.info;
        info.textContent = text;
        if (duration > 0) {
          clearTimeout(info._timeout);
          info._timeout = setTimeout(() => {
            info.textContent = "";
          }, duration);
        }
      }
    </script>
  </body>
</html>
